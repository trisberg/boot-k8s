= Spring Boot Apps on K8s
Doc Writer <doc.writer@asciidoctor.org>
v0, 2017-08-13
:toc:
:toclevels: 3

== Install Kubernetes and kubectl CLI

* https://kubernetes.io/docs/tasks/tools/install-minikube/[install minikube]

	minikube start --cpus=4 --memory=4096

* https://kubernetes.io/docs/tasks/tools/install-kubectl/[install kubectl]

	kubectl version

== kubectl, Deployments, Services

* k8s overview
	- pod/containers, nodes, master, API, scheduler
	- kubectl - common commands
	- minikube - quick install

=== Hello World App

* run with kubectl commands

* show running yaml/json

==== Demo 1 - Simple Hello Kubernetes app

* simple Boot app

	curl https://start.spring.io/starter.zip -d dependencies=web,actuator \
	     -d groupId=com.springdeveloper.k8s -d artifactId=hello \
	     -d name=hello -d baseDir=hello -o hello.zip
	unzip hello.zip

* `HelloApplication.java`

	@SpringBootApplication
	public class HelloApplication {
		public static void main(String[] args) {
			SpringApplication.run(HelloApplication.class, args);
		}

* Add:

		@RestController
		class HelloController {
			@GetMapping("/hello")
			String hello() {
				return "Hello Kubernauts!";
			}
		}
	}

* `application.properties`

	endpoints.env.sensitive=false

* `Dockerfile`

	FROM java:8
	VOLUME /tmp
	ADD ./target/hello-*.jar /hello.jar
	RUN bash -c 'touch /hello.jar'
	ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/hello.jar"]


* Build Docker image

	docker build -t trisberg/hello .

* Test Docker container locally

	docker run -p 8080:8080 trisberg/hello

* Push Docker container to a registry

	docker push trisberg/hello

* Run a deployment

	kubectl run hello --image trisberg/hello --port=8080
	kubectl expose deployment hello --type=NodePort
	minikube service hello --url

* Test the app

	curl $(minikube service hello --url)/hello

== ConfigMap, Secrets

=== Small Microservice - Actor REST Repository App

* Connecting to services running on k8s

* Using configuration files do define k8s resources

* Using Maven plug-in to build Docker image

* Use `org.springframework.cloud:spring-cloud-starter-kubernetes` for ConfigMaps and Secrets

==== Demo 2 - Simple REST Repository App

* Small CRUD JPA Repository

	curl https://start.spring.io/starter.zip -d dependencies=web,actuator,jpa,data-rest,mysql,hsql \
	     -d groupId=com.springdeveloper.k8s -d artifactId=actors \
	     -d name=actors -d baseDir=actors -o actors.zip
	unzip actors.zip

* Add an Actor Entity

.Actor
[source,java]
----
package com.springdeveloper.k8s.actors;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Actor {

	@Id
	@GeneratedValue
	Long id;

	String name;

	int age;

	public Long getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}
----

* Add an ActorRepository

.ActorRepository
[source,java]
----
package com.springdeveloper.k8s.actors;

import java.util.List;

import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.repository.query.Param;

public interface ActorRepository extends PagingAndSortingRepository<Actor, Long> {

	List<Actor> findByName(@Param("name") String name);

}
----

.application-default.properties
[source,props]
----
endpoints.env.sensitive=false
spring.datasource.url=jdbc:hsqldb:file:target/testdb
spring.datasource.username=sa
spring.jpa.hibernate.ddl-auto=create
spring.datasource.initialize=true
----

* Add actor records (already added in database init):

	curl -i -X POST -H "Content-Type:application/json" -d "{  \"name\" : \"Dolph Lundgren\",  \"age\" : 59 }" http://localhost:8080/actors

* Test locally - http://localhost:8080

* Add config porperties for k8s

.application-kubernetes.properties
[source,props]
----
endpoints.env.sensitive=false
spring.jpa.hibernate.ddl-auto=update
spring.datasource.initialize=false
----

We'll use standalone MySQL database that we'll configure later

* Add Docker Maven plug-in

.src/main/docker/assembly.xml
[source,xml]
----
<assembly
        xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2
            http://maven.apache.org/xsd/assembly-1.1.2.xsd">
    <id>actors</id>
    <dependencySets>
        <dependencySet>
            <includes>
                <include>com.springdeveloper.k8s:actors</include>
            </includes>
            <outputDirectory>.</outputDirectory>
            <outputFileNameMapping>actors.jar</outputFileNameMapping>
        </dependencySet>
    </dependencySets>
</assembly>
----

.pom.xml
[source,xml]
----
...
			<plugin>
				<groupId>io.fabric8</groupId>
				<artifactId>docker-maven-plugin</artifactId>
				<version>0.14.2</version>
				<configuration>
					<images>
						<image>
							<name>actors</name>
							<build>
								<from>java:8-alpine</from>
								<volumes>
									<volume>/tmp</volume>
								</volumes>
								<entryPoint>
									<exec>
										<arg>java</arg>
										<arg>-jar</arg>
										<arg>/maven/actors.jar</arg>
									</exec>
								</entryPoint>
								<assembly>
									<descriptor>assembly.xml</descriptor>
								</assembly>
							</build>
						</image>
					</images>
				</configuration>
			</plugin>
...
----

* Add Spring Cloud Kubernetes Starter (originally Fabric8, now spring-cloud-incubator project)

.pom.xml
[source,xml]
----
...
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-kubernetes</artifactId>
			<version>0.2.0.RELEASE</version>
		</dependency>
...
----

.config/actors-deployment.yaml
[source,yaml]
----
...
        env:
        - name: SERVER_PORT
          value: '80'
        - name: SPRING_PROFILES_ACTIVE
          value: kubernetes
        - name: SPRING_CLOUD_KUBERNETES_SECRETS_ENABLE_API
          value: 'true'
        - name: SPRING_CLOUD_KUBERNETES_SECRETS_NAME
          value: mysql
        - name: SPRING_CLOUD_KUBERNETES_CONFIG_NAME
          value: actors
...
----

.config/actors-config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: actors
  labels:
    app: actors
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://${MYSQL_SERVICE_HOST}:${MYSQL_SERVICE_PORT}/mysql
        username: root
        password: ${mysql-root-password}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----

* Configure a MySQL deployment and service

.mysql/mysql-deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.6
        name: mysql
        env:
          - name: MYSQL_ROOT_PASSWORD
            # You can change this password - if you do change the base64 encoded value in the secrets file
            value: yourpassword
        ports:
          - containerPort: 3306
            name: mysql
        volumeMounts:
          - name: data
            mountPath: /var/lib/mysql
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: mysql
----

.mysql/mysql-svc.yaml
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
----

.mysql/mysql-pvc.yaml
[source,yaml]
----
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql
  labels:
    app: mysql
  annotations:
    volume.alpha.kubernetes.io/storage-class: default
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi
----

.mysql/mysql-secrets.yaml
[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: mysql
  labels:
    app: mysql
data:
  mysql-root-password: eW91cnBhc3N3b3Jk
----

* Create a MySQL deployment and service

----
kubectl apply -f ./mysql/
----

* Build app and push Docker image

----
./mvnw clean package docker:build
docker tag actors $USER/actors:0.0.2
docker push $USER/actors:0.0.2
----

* Deploy app to k8s

----
kubectl apply -f config/
----

* Get status

----
$ kubectl get all
NAME                         READY     STATUS    RESTARTS   AGE
po/actors-2063423708-g81sz   1/1       Running   0          2h
po/mysql-777890292-ht5v2     1/1       Running   0          13h

NAME             CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
svc/actors       10.0.0.185   <nodes>       80:31012/TCP   2h
svc/kubernetes   10.0.0.1     <none>        443/TCP        13h
svc/mysql        10.0.0.83    <none>        3306/TCP       13h

NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/actors   1         1         1            1           2h
deploy/mysql    1         1         1            1           13h

NAME                   DESIRED   CURRENT   READY     AGE
rs/actors-2063423708   1         1         1         2h
rs/mysql-777890292     1         1         1         13h
----

* Add some actor records (empty table in database initially):

	./data/add-actors.sh

== Google Cloud Platform services

=== Connecting to Cloud SQL for MySQL

* Enable the Cloud SQL API

* Create a MySQL Database (2nd Generation)

* Create a Service Account

* Use a Side Car Proxy

==== Demo 3 - Simple REST Repository App using Cloud SQL for MySQL

* Create a service account

	Role: Cloud SQL Client
	
Download the JSON private key file

* Create the user account for the proxy

	gcloud sql users create proxyuser cloudsqlproxy~% --instance=spring-mysql
	gcloud sql users set-password proxyuser cloudsqlproxy~% \ 
	    --instance=spring-mysql --password=<your-password>

* Get your instance connection name

	gcloud sql instances describe spring-mysql
	...
	connectionName: <project>:us-central1:spring-mysql
	...

* Create your secrets
	kubectl create secret generic cloudsql-instance-credentials --from-file=credentials.json=<private-key-file-path>
	kubectl create secret generic cloudsql-db-credentials --from-literal=username=proxyuser --from-literal=password=<your-password>

* Update your ConfigMap/Deployment configuration files

.config/actors-deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: actors
  labels:
    app: actors
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: actors
    spec:
      containers:
      - image: gcr.io/cloudsql-docker/gce-proxy:1.09
        name: cloudsql-proxy
        command: ["/cloud_sql_proxy", "--dir=/cloudsql",
                  "-instances=<project>:us-central1:spring-mysql=tcp:3306",
                  "-credential_file=/secrets/cloudsql/credentials.json"]
        volumeMounts:
          - name: cloudsql-instance-credentials
            mountPath: /secrets/cloudsql
            readOnly: true
          - name: ssl-certs
            mountPath: /etc/ssl/certs
          - name: cloudsql
            mountPath: /cloudsql
      - name: actors
        image: trisberg/actors:0.0.2
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 1.0
            memory: 1024Mi
          requests:
            cpu: 0.5
            memory: 640Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 90
          periodSeconds: 15
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 45
          periodSeconds: 15
          timeoutSeconds: 5
        env:
        - name: SERVER_PORT
          value: '80'
        - name: SPRING_PROFILES_ACTIVE
          value: kubernetes
        - name: SPRING_CLOUD_KUBERNETES_CONFIG_NAME
          value: actors
        - name: SPRING_CLOUD_CONFIG_ENABLED
          value: 'false'
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: cloudsql-db-credentials
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: cloudsql-db-credentials
              key: password
      volumes:
        - name: cloudsql-instance-credentials
          secret:
            secretName: cloudsql-instance-credentials
        - name: ssl-certs
          hostPath:
            path: /etc/ssl/certs
        - name: cloudsql
          emptyDir:
----

.config/actors-config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: actors
  labels:
    app: actors
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://127.0.0.1:3306/test
        username: ${DB_USER}
        password: ${DB_PASSWORD}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----


== Service Discovery - Eureka

== Circuit-breaker - Hystrix

== Service Mesh - Istio

== Packaging - Helm

Create a Helm chart for the `actors` app

----
cd charts/
helm create actors
----

.actors/requirements.yaml
[source,yaml]
----
dependencies:
- name:  mysql
  version: 0.2.8
  repository: https://kubernetes-charts.storage.googleapis.com/
----

.actors/Chart.yaml
[source,yaml]
----
apiVersion: v1
description: A Helm chart for Kubernetes
name: actors
version: 0.1.0
appVersion: 0.0.2
home: https://github.com/trisberg/boot-k8s
sources:
- https://github.com/trisberg/boot-k8s
icon: https://raw.githubusercontent.com/trisberg/boot-k8s/master/spring-boot-project-logo.png
maintainers:
- name: Thomas Risberg
  email: trisberg@pivotal.io
----

.actors/values.yaml
[source,yaml]
----
# Default values for actors.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
replicaCount: 1
image:
  repository: trisberg/actors
  tag: 0.0.2
  pullPolicy: IfNotPresent
service:
  name: actors
  # Use NodePort without load balancer and LoadBalancer for env that have one
  type: NodePort
  externalPort: 80
  internalPort: 8080
ingress:
  enabled: false
  # Used to create Ingress record (should used with service.type: ClusterIP).
  hosts:
    - chart-example.local
  annotations:
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  tls:
    # Secrets must be manually created in the namespace.
    # - secretName: chart-example-tls
    #   hosts:
    #     - chart-example.local
resources:
  limits:
    cpu: 500m
    memory: 1024Mi
  requests:
    cpu: 200m
    memory: 512Mi
----

.actors/templates/service.yaml
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: {{ template "fullname" . }}
  labels:
    app: {{ template "name" . }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.externalPort }}
      targetPort: {{ .Values.service.internalPort }}
      protocol: TCP
      name: {{ .Values.service.name }}
  selector:
    app: {{ template "name" . }}
    release: {{ .Release.Name }}
----

.actors/templates/config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "fullname" . }}
  labels:
    app: {{ template "name" . }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://{{ .Release.Name }}-mysql:3306/mysql
        username: root
        password: ${mysql-root-password}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----

.actors/templates/deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: {{ template "fullname" . }}
  labels:
    app: {{ template "name" . }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
spec:
  replicas: {{ .Values.replicaCount }}
  template:
    metadata:
      labels:
        app: {{ template "name" . }}
        release: {{ .Release.Name }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: {{ .Values.service.internalPort }}
          resources:
            limits:
              cpu: {{ .Values.resources.limits.cpu }}
              memory: {{ .Values.resources.limits.memory }}
            requests:
              cpu: {{ .Values.resources.requests.cpu }}
              memory: {{ .Values.resources.requests.cpu }}
          livenessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.internalPort }}
            initialDelaySeconds: 60
          readinessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.internalPort }}
            initialDelaySeconds: 60
          env:
          - name: SPRING_PROFILES_ACTIVE
            value: kubernetes
          - name: SPRING_CLOUD_KUBERNETES_SECRETS_ENABLE_API
            value: 'true'
          - name: SPRING_CLOUD_KUBERNETES_SECRETS_NAME
            value: {{ .Release.Name }}-mysql
          - name: SPRING_CLOUD_KUBERNETES_CONFIG_NAME
            value: {{ template "fullname" . }}
          - name: SPRING_CLOUD_CONFIG_ENABLED
            value: 'false'
          resources:
{{ toYaml .Values.resources | indent 12 }}
    {{- if .Values.nodeSelector }}
      nodeSelector:
{{ toYaml .Values.nodeSelector | indent 8 }}
    {{- end }}
----

Next, lint, package and serve up the chart:

----
helm lint actors
helm dep update actors
helm package actors
helm repo index .
helm serve
----

Now, install the chart:

----
helm init
helm install --name test local/actors
----

Delete the chart installation:

----
helm delete test --purge
----

== New Developments

=== Open Service API / Kubernetes Service Catalog

=== KuBo / PKS
