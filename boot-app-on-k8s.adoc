= Spring Boot Apps on K8s
Doc Writer <doc.writer@asciidoctor.org>
v0.0.1, 2017-08-13
:toc:
:toclevels: 3

== Install Kubernetes and kubectl CLI

* https://kubernetes.io/docs/tasks/tools/install-minikube/[install minikube]

	cd ~/Downloads/
	mv minikube-darwin-amd64 minikube
	chmod +x minikube
	mv minikube /usr/local/bin/minikube
	minikube start --cpus=4 --memory=4096

* https://kubernetes.io/docs/tasks/tools/install-kubectl/[install kubectl]

	kubectl version

== kubectl, Deployments, Services

* k8s overview
	- pod/containers, nodes, master, API, scheduler
	- kubectl - common commands
	- minikube - quick install
	
=== Hello World App

* run with kubectl commands

* show running yaml/json

==== Demo 1 - Simple Hello Kubernetes app

* simple Boot app
	
	curl https://start.spring.io/starter.zip -d dependencies=web,actuator \ 
	     -d groupId=com.springdeveloper.k8s -d artifactId=hello \
	     -d name=hello -d baseDir=hello -o hello.zip
	unzip hello.zip

* `HelloApplication.java`

	@SpringBootApplication
	public class HelloApplication {
		public static void main(String[] args) {
			SpringApplication.run(HelloApplication.class, args);
		}

* Add:

		@RestController
		class HelloController {
			@GetMapping("/hello")
			String hello() {
				return "Hello Kubernauts!";
			}
		}
	}

* `application.properties`

	endpoints.env.sensitive=false

* `Dockerfile`
	
	FROM java:8
	VOLUME /tmp
	ADD ./target/hello-*.jar /hello.jar
	RUN bash -c 'touch /hello.jar'
	ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/hello.jar"]
	

* Build Docker image
	
	docker build -t trisberg/hello .
	
* Test Docker container locally
	
	docker run -p 8080:8080 trisberg/hello

* Push Docker container to a registry

	docker push trisberg/hello

* Run a deployment

	kubectl run hello --image trisberg/hello --port=8080
	kubectl expose deployment hello --type=NodePort
	minikube service hello --url

* Test the app
	
	curl $(minikube service hello --url)/hello

== ConfigMap, Secrets

=== Small Microservice - Actor REST Repository App

* Connecting to services running on k8s

* Using configuration files do define k8s resources

* Using Maven plug-in to build Docker image

* Use `io.fabric8:spring-cloud-starter-kubernetes` for ConfigMaps and Secrets

==== Demo 2 - Simple REST Repository App

* Small CRUD JPA Repository

	curl https://start.spring.io/starter.zip -d dependencies=web,actuator,jpa,data-rest,mysql,hsql \
	     -d groupId=com.springdeveloper.k8s -d artifactId=actors \
	     -d name=actors -d baseDir=actors -o actors.zip
	unzip actors.zip

* Add an Actor Entity

.Actor
[source,java]
----
package com.springdeveloper.k8s.actors;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Actor {

	@Id
	@GeneratedValue
	Long id;

	String name;

	int age;

	public Long getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}
----

* Add an ActorRepository

.ActorRepository
[source,java]
----
package com.springdeveloper.k8s.actors;

import java.util.List;

import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.repository.query.Param;

public interface ActorRepository extends PagingAndSortingRepository<Actor, Long> {

	List<Actor> findByName(@Param("name") String name);

}
----

.application.properties
[source,props]
----
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test
spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.username=spring
spring.datasource.password=spring
spring.jpa.hibernate.ddl-auto=create
endpoints.env.sensitive=false
----

* Add actor records (already added in database init):

	curl -i -X POST -H "Content-Type:application/json" -d "{  \"name\" : \"Dolph Lundgren\",  \"age\" : 59 }" http://localhost:8080/actors
	
* Add Docker plug-in

.src/main/docker/assembly.xml
[source,xml]
----
<assembly
        xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2
            http://maven.apache.org/xsd/assembly-1.1.2.xsd">
    <id>actors</id>
    <dependencySets>
        <dependencySet>
            <includes>
                <include>com.springdeveloper.k8s:actors</include>
            </includes>
            <outputDirectory>.</outputDirectory>
            <outputFileNameMapping>actors.jar</outputFileNameMapping>
        </dependencySet>
    </dependencySets>
</assembly>
----

.pom.xml
[source,xml]
----
...
			<plugin>
				<groupId>io.fabric8</groupId>
				<artifactId>docker-maven-plugin</artifactId>
				<version>0.14.2</version>
				<configuration>
					<images>
						<image>
							<name>actors</name>
							<build>
								<from>java:8-alpine</from>
								<volumes>
									<volume>/tmp</volume>
								</volumes>
								<entryPoint>
									<exec>
										<arg>java</arg>
										<arg>-jar</arg>
										<arg>/maven/actors.jar</arg>
									</exec>
								</entryPoint>
								<assembly>
									<descriptor>assembly.xml</descriptor>
								</assembly>
							</build>
						</image>
					</images>
				</configuration>
			</plugin>
...
----

* Add Spring Cloud Kubernetes plug-in (originally Fabric8, now spring-cloud-incubator project)

.pom.xml
[source,xml]
----
...
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-kubernetes</artifactId>
			<version>0.2.0.RELEASE</version>
		</dependency>
...
----

.config/actors-deployment.yaml
[source,yaml]
----
...
        env:
        - name: SERVER_PORT
          value: '80'
        - name: SPRING_PROFILES_ACTIVE
          value: kubernetes
        - name: SPRING_CLOUD_KUBERNETES_SECRETS_ENABLE_API
          value: 'true'
        - name: SPRING_CLOUD_KUBERNETES_SECRETS_NAME
          value: mysql
        - name: SPRING_CLOUD_KUBERNETES_CONFIG_NAME
          value: actors
...
----

.config/actors-config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: actors
  labels:
    app: actors
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://${MYSQL_SERVICE_HOST}:${MYSQL_SERVICE_PORT}/mysql
        username: root
        password: ${mysql-root-password}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----

* Configure a MySQL deployment and service

.mysql/mysql-deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.6
        name: mysql
        env:
          - name: MYSQL_ROOT_PASSWORD
            # You can change this password - if you do change the base64 encoded value in the secrets file
            value: yourpassword
        ports:
          - containerPort: 3306
            name: mysql
        volumeMounts:
          - name: data
            mountPath: /var/lib/mysql
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: mysql
----

.mysql/mysql-svc.yaml
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
----

.mysql/mysql-pvc.yaml
[source,yaml]
----
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql
  labels:
    app: mysql
  annotations:
    volume.alpha.kubernetes.io/storage-class: default
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi
----

.mysql/mysql-secrets.yaml
[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: mysql
  labels:
    app: mysql
data:
  mysql-root-password: eW91cnBhc3N3b3Jk
----

* Create a MySQL deployment and service

----
kubectl apply -f ./mysql/
----

* Build app and push Docker image

----
./mvnw clean package docker:build
docker tag actors $USER/actors:0.0.1
docker push $USER/actors:0.0.1
----

* Deploy app to k8s

----
kubectl apply -f config/
----

* Get status

----
$ kubectl get all
NAME                         READY     STATUS    RESTARTS   AGE
po/actors-2063423708-g81sz   1/1       Running   0          2h
po/mysql-777890292-ht5v2     1/1       Running   0          13h

NAME             CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
svc/actors       10.0.0.185   <nodes>       80:31012/TCP   2h
svc/kubernetes   10.0.0.1     <none>        443/TCP        13h
svc/mysql        10.0.0.83    <none>        3306/TCP       13h

NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/actors   1         1         1            1           2h
deploy/mysql    1         1         1            1           13h

NAME                   DESIRED   CURRENT   READY     AGE
rs/actors-2063423708   1         1         1         2h
rs/mysql-777890292     1         1         1         13h
----

* Add some actor records (empty table in database initially):

	./data/add-actors.sh 

== Service Discovery - Eureka

== Service Mesh - Istio

== Packaging - Helm

== New Developments

=== Open Service API / Kubernetes Service Catalog

=== KuBo
