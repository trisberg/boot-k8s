= Spring Boot Apps on K8s
Doc Writer <doc.writer@asciidoctor.org>
v0, 2017-08-13
:doctype: book
:toc:
:toclevels: 3
:attributes: allow-uri-read

== Install Kubernetes and kubectl CLI

. Install Minikube from https://kubernetes.io/docs/tasks/tools/install-minikube/
+
Then, start Minikube:
+
	minikube start
+
. Install `kubectl` from https://kubernetes.io/docs/tasks/tools/install-kubectl/
+
Use `kubectl` to check the versions:
+
	kubectl version

== Introducing kubectl, Deployments, Services

=== Kubernetes overview
* pod/containers, nodes, master, API, scheduler
* kubectl - common commands
* minikube - quick install

=== Boot app basics
* create a new app project
* modify and build app
* build and push Docker image
* run app with kubectl commands
* show enviroinment variables
* show running yaml config files

=== Demo 1 - Simple Hello Spring Boot/Kubernetes app

. Create a simple Boot app
+
----
curl https://start.spring.io/starter.zip -d bootVersion=1.5.6.RELEASE \
     -d dependencies=web,actuator \
     -d groupId=com.springdeveloper.k8s -d artifactId=hello \
     -d name=hello -d baseDir=hello -o hello.zip
unzip hello.zip
cd hello
----

. Add a `@RestController` and a mapping for `/hello`:
+
.HelloApplication.java
[subs=+quotes]
----
package com.springdeveloper.k8s.hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
*import org.springframework.web.bind.annotation.GetMapping;*
*import org.springframework.web.bind.annotation.RestController;*

@SpringBootApplication
public class HelloApplication {
	public static void main(String[] args) {
		SpringApplication.run(HelloApplication.class, args);
	}

	*@RestController*
	*class HelloController {*
		*@GetMapping("/hello")*
		*String hello() {*
			*return "Hello Kubernauts!";*
		*}*
	*}*
}
----

. Add a property disabling security for the `env` endpoint so we can inspect environment variables added by Kubernetes 
+
.application.properties
----
endpoints.env.sensitive=false
----

. Create a `Dockerfile` so we can package this app as a Docker image
+
.Dockerfile
----
FROM java:8
VOLUME /tmp
ADD ./target/hello-*.jar /hello.jar
RUN bash -c 'touch /hello.jar'
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/hello.jar"]
----

. Build the app and the Docker image 
+
(we are assuming that you have a DockerHub account matching your username here, if that is not the case adjust accordingly)
+
----
./mvnw clean package
docker build -t $USER/hello .
----

. Test Docker container locally
+
----
docker run -p 8080:8080 $USER/hello
curl http://localhost:8080/hello
----

. Push Docker container to a new registry for your DockerHub account
+
----
docker push $USER/hello
----

. Run a Kubernetes deployment on the running Minikube cluster
+
----
kubectl run hello --image trisberg/hello --port=8080
kubectl expose deployment hello --type=NodePort
minikube service hello --url
----

. Test the app
+
----
curl $(minikube service hello --url)/hello
----

. Inspect environment variables and Kubernetes deployment/service yaml
+
----
curl $(minikube service hello --url)/env | python -m json.tool
kubectl get deploy/hello -o yaml
kubectl get svc/hello -o yaml
----

. Delete the resources created for `hello`
+
----
kubectl delete all -l run=hello
----

== Using ConfigMap, Secrets

* Connecting to services running on k8s

* Using configuration files do define k8s resources

* Using Maven plug-in to build Docker image

* Use `org.springframework.cloud:spring-cloud-starter-kubernetes` for ConfigMaps and Secrets

=== Demo 2 - Simple REST Repository App

. Create a small CRUD JPA Repository app
+
----
curl https://start.spring.io/starter.zip -d bootVersion=1.5.6.RELEASE \
    -d dependencies=web,actuator,jpa,data-rest,mysql,hsql \
    -d groupId=com.springdeveloper.k8s -d artifactId=actors \
    -d name=actors -d baseDir=actors -o actors.zip
unzip actors.zip
cd actors
----

. Add an Actor Entity
+
.Actor
[source,java]
----
package com.springdeveloper.k8s.actors;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Entity
public class Actor {

	@Id
	@GeneratedValue
	Long id;

	String name;

	int age;

	public Long getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}
----

. Add an ActorRepository
+
.ActorRepository
[source,java]
----
package com.springdeveloper.k8s.actors;

import java.util.List;

import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.data.repository.query.Param;

public interface ActorRepository extends PagingAndSortingRepository<Actor, Long> {

	List<Actor> findByName(@Param("name") String name);

}
----

. Create default properties file for running app locally
+
.application-default.properties
[source,props]
----
endpoints.env.sensitive=false
spring.datasource.url=jdbc:hsqldb:file:target/testdb
spring.datasource.username=sa
spring.jpa.hibernate.ddl-auto=create
spring.datasource.initialize=true
----

. Build and run the app locally
+
----
./mvnw clean package
java -jar target/actors-0.0.1-SNAPSHOT.jar
----

. You can add actor records:
+
----
curl -i -X POST -H "Content-Type:application/json" -d "{  \"name\" : \"Dolph Lundgren\",  \"age\" : 59 }" http://localhost:8080/actors
----

. Test
+
----
curl http://localhost:8080/actors | python -m json.tool
----

. Add config properties for running on Kubernetes
+
We'll use standalone MySQL database that we'll configure later
+
.application-kubernetes.properties
[source,props]
----
endpoints.env.sensitive=false
spring.jpa.hibernate.ddl-auto=update
spring.datasource.initialize=false
----

. Add Docker Maven plug-in
+
.src/main/docker/assembly.xml
[source,xml]
----
<assembly
        xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2
            http://maven.apache.org/xsd/assembly-1.1.2.xsd">
    <id>actors</id>
    <dependencySets>
        <dependencySet>
            <includes>
                <include>com.springdeveloper.k8s:actors</include>
            </includes>
            <outputDirectory>.</outputDirectory>
            <outputFileNameMapping>actors.jar</outputFileNameMapping>
        </dependencySet>
    </dependencySets>
</assembly>
----
+
.pom.xml
[source,xml]
----
...
			<plugin>
				<groupId>io.fabric8</groupId>
				<artifactId>docker-maven-plugin</artifactId>
				<version>0.21.0</version>
				<configuration>
					<images>
						<image>
							<name>actors</name>
							<build>
								<from>java:8-alpine</from>
								<volumes>
									<volume>/tmp</volume>
								</volumes>
								<entryPoint>
									<exec>
										<arg>java</arg>
										<arg>-jar</arg>
										<arg>/maven/actors.jar</arg>
									</exec>
								</entryPoint>
								<assembly>
									<descriptor>assembly.xml</descriptor>
								</assembly>
							</build>
						</image>
					</images>
				</configuration>
			</plugin>
...
----

. Add Spring Cloud Kubernetes Starter (originally Fabric8, now spring-cloud-incubator project)
+
.pom.xml
[source,xml]
----
...
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-kubernetes-config</artifactId>
			<version>0.2.0.RELEASE</version>
		</dependency>
...
----
+
.config/actors-deployment.yaml
[source,yaml]
----
...
        env:
        - name: SERVER_PORT
          value: '80'
        - name: SPRING_PROFILES_ACTIVE
          value: kubernetes
        - name: SPRING_CLOUD_KUBERNETES_SECRETS_ENABLE_API
          value: 'true'
        - name: SPRING_CLOUD_KUBERNETES_SECRETS_NAME
          value: mysql
        - name: SPRING_CLOUD_KUBERNETES_CONFIG_NAME
          value: actors
...
----
+
.config/actors-config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: actors
  labels:
    app: actors
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://${MYSQL_SERVICE_HOST}:${MYSQL_SERVICE_PORT}/mysql
        username: root
        password: ${mysql-root-password}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----
+
. Configure a MySQL deployment and service
+
.mysql/mysql-deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - image: mysql:5.6
        name: mysql
        env:
          - name: MYSQL_ROOT_PASSWORD
            # You can change this password - if you do change the base64 encoded value in the secrets file
            value: yourpassword
        ports:
          - containerPort: 3306
            name: mysql
        volumeMounts:
          - name: data
            mountPath: /var/lib/mysql
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: mysql
----
+
.mysql/mysql-svc.yaml
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: mysql
  labels:
    app: mysql
spec:
  ports:
    - port: 3306
  selector:
    app: mysql
----
+
.mysql/mysql-pvc.yaml
[source,yaml]
----
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql
  labels:
    app: mysql
  annotations:
    volume.alpha.kubernetes.io/storage-class: default
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi
----
+
.mysql/mysql-secrets.yaml
[source,yaml]
----
apiVersion: v1
kind: Secret
metadata:
  name: mysql
  labels:
    app: mysql
data:
  mysql-root-password: eW91cnBhc3N3b3Jk
----

. Create a MySQL deployment and service
+
----
kubectl apply -f ./mysql/
----

. Build app and push Docker image
+
----
./mvnw clean package docker:build
docker tag actors $USER/actors:0.0.2
docker push $USER/actors:0.0.2
----

. Deploy app to k8s
+
----
kubectl apply -f config/
----

. Get status
+
----
$ kubectl get all
NAME                         READY     STATUS    RESTARTS   AGE
po/actors-2063423708-g81sz   1/1       Running   0          2h
po/mysql-777890292-ht5v2     1/1       Running   0          13h

NAME             CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
svc/actors       10.0.0.185   <nodes>       80:31012/TCP   2h
svc/kubernetes   10.0.0.1     <none>        443/TCP        13h
svc/mysql        10.0.0.83    <none>        3306/TCP       13h

NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deploy/actors   1         1         1            1           2h
deploy/mysql    1         1         1            1           13h

NAME                   DESIRED   CURRENT   READY     AGE
rs/actors-2063423708   1         1         1         2h
rs/mysql-777890292     1         1         1         13h
----

. Add some actor records (empty table in database initially):
+
----
./data/add-actors.sh
----

== Connecting to Google Cloud Platform services

* Enable the Cloud SQL API

* Create a MySQL Database (2nd Generation)

* Create a Service Account

* Use a Side Car Proxy

=== Demo 3 - Simple REST Repository App using Cloud SQL for MySQL

* Create a service account

	Role: Cloud SQL Client
	
Download the JSON private key file

* Create the user account for the proxy

	gcloud sql users create proxyuser cloudsqlproxy~% --instance=spring-mysql
	gcloud sql users set-password proxyuser cloudsqlproxy~% \ 
	    --instance=spring-mysql --password=<your-password>

* Get your instance connection name

	gcloud sql instances describe spring-mysql
	...
	connectionName: <project>:us-central1:spring-mysql
	...

* Create your secrets
	kubectl create secret generic cloudsql-instance-credentials --from-file=credentials.json=<private-key-file-path>
	kubectl create secret generic cloudsql-db-credentials --from-literal=username=proxyuser --from-literal=password=<your-password>

* Update your ConfigMap/Deployment configuration files

.config/actors-deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: actors
  labels:
    app: actors
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: actors
    spec:
      containers:
      - image: gcr.io/cloudsql-docker/gce-proxy:1.09
        name: cloudsql-proxy
        command: ["/cloud_sql_proxy", "--dir=/cloudsql",
                  "-instances=<project>:us-central1:spring-mysql=tcp:3306",
                  "-credential_file=/secrets/cloudsql/credentials.json"]
        volumeMounts:
          - name: cloudsql-instance-credentials
            mountPath: /secrets/cloudsql
            readOnly: true
          - name: ssl-certs
            mountPath: /etc/ssl/certs
          - name: cloudsql
            mountPath: /cloudsql
      - name: actors
        image: trisberg/actors:0.0.2
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: 1.0
            memory: 1024Mi
          requests:
            cpu: 0.5
            memory: 640Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 90
          periodSeconds: 15
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 45
          periodSeconds: 15
          timeoutSeconds: 5
        env:
        - name: SERVER_PORT
          value: '80'
        - name: SPRING_PROFILES_ACTIVE
          value: kubernetes
        - name: SPRING_CLOUD_KUBERNETES_CONFIG_NAME
          value: actors
        - name: SPRING_CLOUD_CONFIG_ENABLED
          value: 'false'
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: cloudsql-db-credentials
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: cloudsql-db-credentials
              key: password
      volumes:
        - name: cloudsql-instance-credentials
          secret:
            secretName: cloudsql-instance-credentials
        - name: ssl-certs
          hostPath:
            path: /etc/ssl/certs
        - name: cloudsql
          emptyDir:
----

.config/actors-config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: actors
  labels:
    app: actors
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://127.0.0.1:3306/test
        username: ${DB_USER}
        password: ${DB_PASSWORD}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----


== Service Discovery - Eureka

== Circuit-breaker - Hystrix

== Service Mesh - Istio

== Packaging - Helm

Create a Helm chart for the `actors` app

----
cd charts/
helm create actors
----

.actors/requirements.yaml
[source,yaml]
----
dependencies:
- name:  mysql
  version: 0.2.8
  repository: https://kubernetes-charts.storage.googleapis.com/
----

.actors/Chart.yaml
[source,yaml]
----
apiVersion: v1
description: A Helm chart for Kubernetes
name: actors
version: 0.1.0
appVersion: 0.0.2
home: https://github.com/trisberg/boot-k8s
sources:
- https://github.com/trisberg/boot-k8s
icon: https://raw.githubusercontent.com/trisberg/boot-k8s/master/spring-boot-project-logo.png
maintainers:
- name: Thomas Risberg
  email: trisberg@pivotal.io
----

.actors/values.yaml
[source,yaml]
----
# Default values for actors.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.
replicaCount: 1
image:
  repository: trisberg/actors
  tag: 0.0.2
  pullPolicy: IfNotPresent
service:
  name: actors
  # Use NodePort without load balancer and LoadBalancer for env that have one
  type: NodePort
  externalPort: 80
  internalPort: 8080
ingress:
  enabled: false
  # Used to create Ingress record (should used with service.type: ClusterIP).
  hosts:
    - chart-example.local
  annotations:
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  tls:
    # Secrets must be manually created in the namespace.
    # - secretName: chart-example-tls
    #   hosts:
    #     - chart-example.local
resources:
  limits:
    cpu: 500m
    memory: 1024Mi
  requests:
    cpu: 200m
    memory: 512Mi
----

.actors/templates/service.yaml
[source,yaml]
----
apiVersion: v1
kind: Service
metadata:
  name: {{ template "fullname" . }}
  labels:
    app: {{ template "name" . }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.externalPort }}
      targetPort: {{ .Values.service.internalPort }}
      protocol: TCP
      name: {{ .Values.service.name }}
  selector:
    app: {{ template "name" . }}
    release: {{ .Release.Name }}
----

.actors/templates/config.yaml
[source,yaml]
----
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "fullname" . }}
  labels:
    app: {{ template "name" . }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
data:
  application.yaml: |-
    security:
      basic:
        enabled: false
    spring:
      datasource:
        url: jdbc:mysql://{{ .Release.Name }}-mysql:3306/mysql
        username: root
        password: ${mysql-root-password}
        driverClassName: com.mysql.jdbc.Driver
        testOnBorrow: true
        validationQuery: "SELECT 1"
----

.actors/templates/deployment.yaml
[source,yaml]
----
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: {{ template "fullname" . }}
  labels:
    app: {{ template "name" . }}
    chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    release: {{ .Release.Name }}
    heritage: {{ .Release.Service }}
spec:
  replicas: {{ .Values.replicaCount }}
  template:
    metadata:
      labels:
        app: {{ template "name" . }}
        release: {{ .Release.Name }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - containerPort: {{ .Values.service.internalPort }}
          resources:
            limits:
              cpu: {{ .Values.resources.limits.cpu }}
              memory: {{ .Values.resources.limits.memory }}
            requests:
              cpu: {{ .Values.resources.requests.cpu }}
              memory: {{ .Values.resources.requests.cpu }}
          livenessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.internalPort }}
            initialDelaySeconds: 60
          readinessProbe:
            httpGet:
              path: /health
              port: {{ .Values.service.internalPort }}
            initialDelaySeconds: 60
          env:
          - name: SPRING_PROFILES_ACTIVE
            value: kubernetes
          - name: SPRING_CLOUD_KUBERNETES_SECRETS_ENABLE_API
            value: 'true'
          - name: SPRING_CLOUD_KUBERNETES_SECRETS_NAME
            value: {{ .Release.Name }}-mysql
          - name: SPRING_CLOUD_KUBERNETES_CONFIG_NAME
            value: {{ template "fullname" . }}
          - name: SPRING_CLOUD_CONFIG_ENABLED
            value: 'false'
          resources:
{{ toYaml .Values.resources | indent 12 }}
    {{- if .Values.nodeSelector }}
      nodeSelector:
{{ toYaml .Values.nodeSelector | indent 8 }}
    {{- end }}
----

Next, lint, package and serve up the chart:

----
helm lint actors
helm dep update actors
helm package actors
helm repo index .
helm serve
----

Now, install the chart:

----
helm init
helm install --name test local/actors
----

Delete the chart installation:

----
helm delete test --purge
----

== New Developments

=== Open Service API / Kubernetes Service Catalog

=== PKS / Kubo
